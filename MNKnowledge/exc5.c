/*
[21-Jun-21 10:21]

Брошура
Напишете на езика C или C++ програма, която по въведено от стандартния вход цяло положително число n
извежда на стандартния изход две редици от номера на страници, които показват как да се отпечата брошура
от n страници. По-точно редиците са такива, че се изпълнява следното.
Нека страниците с номера от едната редица се отпечатват по четири на лист от едната
му страна във вида
	а б
	в г
(редът на буквите показва реда на разполагане на страниците).
Обръщайки така получения напечатан сноп хартия, по същия начин страниците с номера от другата редица се
отпечатват на обратната страна на листовете. Сега, ако снопът хартия се разреже хоризонтално през средата
и горната половина обърнем върху долната, а после този по-дебел сноп прегънем вертикално през средата,
налагайки лявата половина върху дясната, получаваме отпечатък на брошурата: страниците са в нужния ред от 1 до n,
а (в зависимост от стойността на n) последните не повече от 7 страници могат да са празни.
В извежданите числови редици на празните страници трябва да отговарят нули вместо истински номера.
Номерата на онези страници, които трябва да бъдат отпечатани „с главата надолу“ (защото след срязването на снопа
се обръщат) се извеждат със знак минус.

Например за n = 8 програмата трябва да изведе
-5 -4 8 1
-3 -6 2 7

а за n = 19:
-13 -12 0 1 -15 -10 0 3 -17 -8 0 5
-7 -18 6 19 -9 -16 4 0 -11 -14 2 0

    ********
    
[Примерно решение]

Ще дадем пример за n = 10. Финалата наредба на страниците може да се опише така:

    (9,10)
    (7,8)
    (5,6)
    (3,4)
    (1,2)

, където наредената двойка (x,y) описва отрязък от лист с лице страница x и гръб страница y.
За да можем да обърнем два пъти наполовина, трябва броят такива отрязъци да се дели на 4.
Затова допълваме с колкото празни страници или отрязъци трябва. В случая купчинката става:

    (0,0)
    (0,0)
    (0,0)
    (9,10)
    (7,8)
    (5,6)
    (3,4)
    (1,2)

Разделяме купчинката на две през средата и обръщаме горната половина наляво.
Така получаваме разпределението на отрязъците преди вертикалния разрез:

(10,9)   (7,8)
(0,0)    (5,6)
(0,0)    (3,4)
(0,0)    (1,2)

Сега отново разделяме двете купчинки през средата и обръщам горните половини нагоре.
Така получавам разпределението на отрязъците преди хоризонталния разрез:

(0,0)    (-6,-5)
(-9,-10) (-8,-7)

(0,0)    (3,4)
(0,0)    (1,2)

Сега имам 4 купчинки, всяка с по 2 слоя от отрязъци. Тъй като печатаме на принципа
[горе ляво]-[горе дясно]-[долу ляво]-[долу дясно], можем веднага да определим лицата:

Долният слой е -9 (горе ляво), -8 (горе дясно), 0 (долу ляво), 1 (долу дясно).
Съответно горният слой е 0 -6 0 3 и цялата редица от лица е -9 -8 0 1 0 -6 0 3.

Тъй като така напечатаният сноп се обръща, гърбовете трябва да се печатат от горния слой надолу.
Спрямо лицата редът им е огледален, т.е [горе дясно]-[горе ляво]-[долу дясно]-[долу ляво].
Така получаваме -5 0 4 0 за горния слой и -7 -10 2 0 за долния слой.

Аналогично за n = 19 получаваме следното.
Целта е:

    (19,0)
    (17,18)
    (15,16)
    (13,14)
    (11,12)
    (9,10)
    (7,8)
    (5,6)
    (3,4)
    (1,2)

, след допълване имаме:

    (0,0)
    (0,0)
    (19,0)
    (17,18)
    (15,16)
    (13,14)
    (11,12)
    (9,10)
    (7,8)
    (5,6)
    (3,4)
    (1,2)

, след обръщане през средата наляво имаме:

(14,13)    (11,12)
(16,15)    (9,10)
(18,17)    (7,8)
(0,19)     (5,6)
(0,0)      (3,4)
(0,0)      (1,2)
	
, след обръщане през средите нагоре имаме:

(-17,-18)  (-8,-7)
(-15,-16)  (-10,-9)
(-13,-14)  (-12,-11)

(0,19)     (5,6)
(0,0)      (3,4)
(0,0)      (1,2)

Сега четем лицата: от долния слой нагоре на принципа [горе ляво]-[горе дясно]-[долу ляво]-[долу дясно]

-13 -12 0 1 -15 -10 0 3 -17 -8 0 5

Сега четем гърбовете: от горния слой надолу на принципа [горе дясно]-[горе ляво]-[долу дясно]-[долу ляво]

-7 -18 6 19 -9 -16 4 0 -11 -14 2 0

Тази идея може да се реализира лесно, например чрез предложената програма.
*/

#include <stdio.h>

int n;

int page(int x){
	return (x > n || x < -n) ? 0:x;
}

int main(){
	scanf("%d", &n);
	
	int p = n / 8;
	if (n % 8) p++;
	
	int m = p * 8;
	int h = p * 4;
	
	int i;
	for (i = 0; i < p; i++){
		printf("%d %d %d %d ", page(-h-2*i-1)	// top left front
			, page(-h+2*i)	// top right front
			, page(m-2*i)	// bottom left front
			, 2*i+1);	// bottom right front
	}
	
	printf("\n");
	
	for (i = p-1; i >= 0; i--){
		printf("%d %d %d %d ", page(-h+2*i+1)	// top left back
			, page(-h-2*i-2)	// top right back
			, page(2*i+2)	// bottom left back
			, page(m-2*i-1));	// bottom right back
	}
	
	return 0;
}
